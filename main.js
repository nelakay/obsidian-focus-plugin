/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FocusPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/types.ts
var DAY_NAMES = {
  0: "Sunday",
  1: "Monday",
  2: "Tuesday",
  3: "Wednesday",
  4: "Thursday",
  5: "Friday",
  6: "Saturday"
};
var DEFAULT_SETTINGS = {
  taskFilePath: "focus-tasks.md",
  maxImmediateTasks: 5,
  planningReminderEnabled: true,
  planningReminderDay: 0,
  // Sunday
  endOfDayReviewEnabled: false,
  endOfDayReviewTime: "21:00",
  vaultSyncMode: "off",
  vaultSyncTag: "#focus",
  vaultSyncFolders: [],
  rolloverImmediateToThisWeek: true,
  rolloverThisWeekToUnscheduled: true,
  hideCompletedTasks: false,
  dailyNotesFolder: "",
  dailyNotesFormat: "YYYY-MM-DD",
  weeklyNotesFolder: "",
  weeklyNotesFormat: "YYYY-[W]WW"
};
var FOCUS_VIEW_TYPE = "focus-view";
var COMMAND_IDS = {
  openFocusView: "productivity-focus:open-view",
  openPlanningView: "productivity-focus:open-planning",
  quickAddTask: "productivity-focus:quick-add-task"
};

// src/FocusView.ts
var import_obsidian = require("obsidian");
var FocusView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.draggedTask = null;
    this.draggedFromSection = null;
    this.selectedTaskIndex = -1;
    this.selectedSection = null;
    this.data = null;
    this.plugin = plugin;
    this.containerEl.addClass("focus-plugin-view");
  }
  getViewType() {
    return FOCUS_VIEW_TYPE;
  }
  getDisplayText() {
    return "Focus";
  }
  getIcon() {
    return "target";
  }
  async onOpen() {
    this.containerEl.addEventListener("keydown", this.handleKeyDown.bind(this));
    this.containerEl.setAttribute("tabindex", "0");
    this.containerEl.addClass("focus-plugin-view");
    await this.render();
  }
  async onClose() {
    this.containerEl.removeEventListener("keydown", this.handleKeyDown.bind(this));
    await Promise.resolve();
  }
  handleKeyDown(e) {
    if (!this.data)
      return;
    const allTasks = [
      ...this.data.tasks.immediate.filter((t) => !t.completed),
      ...this.data.tasks.thisWeek.filter((t) => !t.completed)
    ];
    if (allTasks.length === 0)
      return;
    switch (e.key) {
      case "ArrowDown":
      case "j":
        e.preventDefault();
        this.selectedTaskIndex = Math.min(this.selectedTaskIndex + 1, allTasks.length - 1);
        this.updateSelection();
        break;
      case "ArrowUp":
      case "k":
        e.preventDefault();
        this.selectedTaskIndex = Math.max(this.selectedTaskIndex - 1, 0);
        this.updateSelection();
        break;
      case "Enter":
      case " ":
        e.preventDefault();
        if (this.selectedTaskIndex >= 0 && this.selectedTaskIndex < allTasks.length) {
          const task = allTasks[this.selectedTaskIndex];
          void this.toggleTaskCompleteById(task.id);
        }
        break;
      case "i":
        e.preventDefault();
        if (this.selectedTaskIndex >= 0) {
          const task = allTasks[this.selectedTaskIndex];
          if (task.section === "thisWeek") {
            void this.moveTaskById(task.id, "thisWeek", "immediate");
          }
        }
        break;
      case "w":
        e.preventDefault();
        if (this.selectedTaskIndex >= 0) {
          const task = allTasks[this.selectedTaskIndex];
          if (task.section === "immediate") {
            void this.moveTaskById(task.id, "immediate", "thisWeek");
          }
        }
        break;
      case "u":
        e.preventDefault();
        if (this.selectedTaskIndex >= 0) {
          const task = allTasks[this.selectedTaskIndex];
          void this.moveTaskById(task.id, task.section, "unscheduled");
          new import_obsidian.Notice("Task moved to unscheduled");
        }
        break;
      case "Escape":
        this.selectedTaskIndex = -1;
        this.updateSelection();
        break;
    }
  }
  updateSelection() {
    this.containerEl.querySelectorAll(".focus-task-selected").forEach((el) => {
      el.removeClass("focus-task-selected");
    });
    if (this.selectedTaskIndex < 0 || !this.data)
      return;
    const allTasks = [
      ...this.data.tasks.immediate.filter((t) => !t.completed),
      ...this.data.tasks.thisWeek.filter((t) => !t.completed)
    ];
    if (this.selectedTaskIndex >= allTasks.length)
      return;
    const task = allTasks[this.selectedTaskIndex];
    const taskEl = this.containerEl.querySelector(`[data-task-id="${task.id}"]`);
    if (taskEl) {
      taskEl.addClass("focus-task-selected");
      taskEl.scrollIntoView({ block: "nearest" });
    }
  }
  async toggleTaskCompleteById(taskId) {
    if (!this.data)
      return;
    for (const section of ["immediate", "thisWeek", "unscheduled"]) {
      const task = this.data.tasks[section].find((t) => t.id === taskId);
      if (task) {
        task.completed = !task.completed;
        await this.plugin.saveTaskData(this.data);
        if (task.sourceFile) {
          await this.plugin.syncTaskCompletionToSource(task);
        }
        await this.render();
        return;
      }
    }
  }
  async moveTaskById(taskId, fromSection, toSection) {
    if (!this.data)
      return;
    if (toSection === "immediate") {
      const activeImmediate = this.data.tasks.immediate.filter((t) => !t.completed);
      if (activeImmediate.length >= this.plugin.settings.maxImmediateTasks) {
        new import_obsidian.Notice(`Maximum ${this.plugin.settings.maxImmediateTasks} tasks in immediate.`);
        return;
      }
    }
    const task = this.data.tasks[fromSection].find((t) => t.id === taskId);
    if (!task)
      return;
    const fromIndex = this.data.tasks[fromSection].findIndex((t) => t.id === taskId);
    if (fromIndex > -1) {
      this.data.tasks[fromSection].splice(fromIndex, 1);
    }
    task.section = toSection;
    this.data.tasks[toSection].push(task);
    await this.plugin.saveTaskData(this.data);
    await this.render();
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("focus-view-container");
    this.data = await this.plugin.loadTaskData();
    const header = container.createEl("div", { cls: "focus-header" });
    header.createEl("h2", { text: "Focus mode", cls: "focus-title" });
    const headerActions = header.createEl("div", { cls: "focus-header-actions" });
    const toggleCompletedBtn = headerActions.createEl("button", {
      cls: "focus-header-btn focus-toggle-completed-btn",
      attr: {
        title: this.plugin.settings.hideCompletedTasks ? "Show completed tasks" : "Hide completed tasks"
      }
    });
    toggleCompletedBtn.innerHTML = this.plugin.settings.hideCompletedTasks ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>';
    toggleCompletedBtn.addEventListener("click", async () => {
      this.plugin.settings.hideCompletedTasks = !this.plugin.settings.hideCompletedTasks;
      await this.plugin.saveSettings();
      await this.render();
    });
    const addButton = headerActions.createEl("button", {
      text: "+",
      cls: "focus-header-btn focus-header-add-btn",
      attr: { title: "Add task" }
    });
    addButton.addEventListener("click", () => {
      this.plugin.openAddTaskModal(true);
    });
    this.renderSection(container, "Immediate", "immediate", this.data.tasks.immediate, this.data);
    this.renderSection(container, "This week", "thisWeek", this.data.tasks.thisWeek, this.data);
    this.renderFooter(container);
    this.updateSelection();
  }
  renderFooter(container) {
    const footer = container.createEl("div", { cls: "focus-footer" });
    const fileLink = footer.createEl("a", {
      text: "Edit task file",
      cls: "focus-file-link",
      href: "#"
    });
    fileLink.addEventListener("click", (e) => {
      e.preventDefault();
      const filePath = this.plugin.settings.taskFilePath;
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian.TFile) {
        void this.plugin.app.workspace.getLeaf().openFile(file);
      }
    });
  }
  renderSection(container, title, section, tasks, data) {
    const sectionEl = container.createEl("div", { cls: `focus-section focus-section-${section}` });
    const headerEl = sectionEl.createEl("div", { cls: "focus-section-header" });
    const activeTasks = tasks.filter((t) => !t.completed);
    const maxIndicator = section === "immediate" ? `/${this.plugin.settings.maxImmediateTasks}` : "";
    headerEl.createEl("span", {
      text: `${title} (${activeTasks.length}${maxIndicator})`,
      cls: "focus-section-title"
    });
    const listEl = sectionEl.createEl("div", {
      cls: "focus-task-list",
      attr: { "data-section": section }
    });
    this.setupDropZone(listEl, section, data);
    let displayTasks = [...tasks];
    if (this.plugin.settings.hideCompletedTasks) {
      displayTasks = displayTasks.filter((t) => !t.completed);
    } else {
      displayTasks.sort((a, b) => {
        if (a.completed === b.completed)
          return 0;
        return a.completed ? 1 : -1;
      });
    }
    for (const task of displayTasks) {
      this.renderTask(listEl, task, section, data);
    }
    if (tasks.length === 0) {
      listEl.createEl("div", {
        text: section === "immediate" ? "Drop tasks here to focus" : "No tasks scheduled",
        cls: "focus-empty-state"
      });
    }
  }
  renderTask(container, task, section, data) {
    const taskEl = container.createEl("div", {
      cls: `focus-task ${task.completed ? "focus-task-completed" : ""}`,
      attr: {
        draggable: task.completed ? "false" : "true",
        "data-task-id": task.id
      }
    });
    if (!task.completed) {
      taskEl.createEl("span", { cls: "focus-drag-handle", text: "\u22EE\u22EE" });
    }
    const checkbox = taskEl.createEl("input", {
      type: "checkbox",
      cls: "focus-checkbox"
    });
    checkbox.checked = task.completed;
    checkbox.addEventListener("change", () => {
      void this.toggleTaskComplete(task, data);
    });
    const titleEl = taskEl.createEl("span", { cls: "focus-task-title" });
    this.renderTaskTitle(titleEl, task.title);
    if (task.sourceFile) {
      const sourceEl = taskEl.createEl("span", {
        cls: "focus-source-indicator",
        attr: { title: `From: ${task.sourceFile}` }
      });
      sourceEl.createEl("span", { text: "\u{1F4C4}" });
    }
    if (task.url) {
      const urlEl = taskEl.createEl("a", {
        cls: "focus-url-indicator",
        href: task.url,
        attr: { title: task.url }
      });
      urlEl.createEl("span", { text: "\u{1F517}" });
      urlEl.addEventListener("click", (e) => {
        e.stopPropagation();
      });
    }
    if (task.doDate) {
      const isOverdue = this.isTaskOverdue(task);
      const dateDisplay = this.formatDoDate(task.doDate, task.doTime);
      const dateEl = taskEl.createEl("span", {
        cls: `focus-date-indicator ${isOverdue ? "focus-date-overdue" : ""}`,
        attr: { title: `Scheduled: ${task.doDate}${task.doTime ? " " + task.doTime : ""}` }
      });
      dateEl.createEl("span", { text: `\u{1F4C5} ${dateDisplay}` });
    }
    if (!task.completed) {
      this.setupDragEvents(taskEl, task, section);
    }
    taskEl.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      this.showContextMenu(e, task, section, data);
    });
  }
  /**
   * Render task title with clickable [[wiki-links]]
   */
  /**
   * Check if a task is overdue based on its do date/time
   */
  isTaskOverdue(task) {
    if (!task.doDate || task.completed)
      return false;
    const now = /* @__PURE__ */ new Date();
    const today = now.toISOString().split("T")[0];
    if (task.doDate < today) {
      return true;
    }
    if (task.doDate === today && task.doTime) {
      const [hours, minutes] = task.doTime.split(":").map(Number);
      const taskTime = new Date(now);
      taskTime.setHours(hours, minutes, 0, 0);
      return now > taskTime;
    }
    return false;
  }
  /**
   * Format do date for display (e.g., "Today", "Tomorrow", "Jan 27", "Jan 27 2:30pm")
   */
  formatDoDate(doDate, doTime) {
    const now = /* @__PURE__ */ new Date();
    const today = now.toISOString().split("T")[0];
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const tomorrowStr = tomorrow.toISOString().split("T")[0];
    let dateStr;
    if (doDate === today) {
      dateStr = "Today";
    } else if (doDate === tomorrowStr) {
      dateStr = "Tomorrow";
    } else {
      const date = /* @__PURE__ */ new Date(doDate + "T00:00:00");
      const month = date.toLocaleDateString("en-US", { month: "short" });
      const day = date.getDate();
      dateStr = `${month} ${day}`;
    }
    if (doTime) {
      const [hours, minutes] = doTime.split(":").map(Number);
      const period = hours >= 12 ? "pm" : "am";
      const hour12 = hours % 12 || 12;
      const timeStr = minutes === 0 ? `${hour12}${period}` : `${hour12}:${minutes.toString().padStart(2, "0")}${period}`;
      return `${dateStr} ${timeStr}`;
    }
    return dateStr;
  }
  /**
   * Render task title with clickable [[wiki-links]]
   */
  renderTaskTitle(container, title) {
    const linkRegex = /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g;
    let lastIndex = 0;
    let match;
    while ((match = linkRegex.exec(title)) !== null) {
      if (match.index > lastIndex) {
        container.appendText(title.slice(lastIndex, match.index));
      }
      const notePath = match[1];
      const displayText = match[2] || match[1];
      const linkEl = container.createEl("a", {
        text: displayText,
        cls: "focus-wiki-link",
        href: "#"
      });
      linkEl.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        void this.plugin.openLinkedNote(`[[${notePath}]]`);
      });
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < title.length) {
      container.appendText(title.slice(lastIndex));
    }
    if (lastIndex === 0) {
      container.setText(title);
    }
  }
  setupDragEvents(taskEl, task, section) {
    taskEl.addEventListener("dragstart", (e) => {
      var _a;
      this.draggedTask = task;
      this.draggedFromSection = section;
      taskEl.addClass("focus-task-dragging");
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", task.id);
    });
    taskEl.addEventListener("dragend", () => {
      taskEl.removeClass("focus-task-dragging");
      this.draggedTask = null;
      this.draggedFromSection = null;
      this.containerEl.querySelectorAll(".focus-drop-active").forEach((el) => {
        el.removeClass("focus-drop-active");
      });
    });
  }
  setupDropZone(listEl, section, data) {
    listEl.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (this.draggedTask && this.draggedFromSection !== section) {
        listEl.addClass("focus-drop-active");
      }
    });
    listEl.addEventListener("dragleave", () => {
      listEl.removeClass("focus-drop-active");
    });
    listEl.addEventListener("drop", (e) => {
      e.preventDefault();
      listEl.removeClass("focus-drop-active");
      if (!this.draggedTask || this.draggedFromSection === section)
        return;
      if (section === "immediate") {
        const activeImmediate = data.tasks.immediate.filter((t) => !t.completed);
        if (activeImmediate.length >= this.plugin.settings.maxImmediateTasks) {
          new import_obsidian.Notice(`Maximum ${this.plugin.settings.maxImmediateTasks} tasks in immediate. Remove one first.`);
          return;
        }
      }
      void this.moveTask(this.draggedTask, this.draggedFromSection, section, data);
    });
  }
  async toggleTaskComplete(task, data) {
    task.completed = !task.completed;
    await this.plugin.saveTaskData(data);
    if (task.sourceFile) {
      await this.plugin.syncTaskCompletionToSource(task);
    }
    await this.render();
  }
  async moveTask(task, fromSection, toSection, data) {
    const fromIndex = data.tasks[fromSection].findIndex((t) => t.id === task.id);
    if (fromIndex > -1) {
      data.tasks[fromSection].splice(fromIndex, 1);
    }
    task.section = toSection;
    data.tasks[toSection].push(task);
    await this.plugin.saveTaskData(data);
    await this.render();
  }
  showContextMenu(e, task, section, data) {
    const menu = new import_obsidian.Menu();
    menu.addItem((item) => {
      item.setTitle(task.completed ? "Mark incomplete" : "Mark complete").setIcon(task.completed ? "circle" : "check-circle").onClick(() => {
        void this.toggleTaskComplete(task, data);
      });
    });
    menu.addSeparator();
    if (section === "thisWeek" && !task.completed) {
      menu.addItem((item) => {
        item.setTitle("Move to immediate").setIcon("arrow-up").onClick(() => {
          const activeImmediate = data.tasks.immediate.filter((t) => !t.completed);
          if (activeImmediate.length >= this.plugin.settings.maxImmediateTasks) {
            new import_obsidian.Notice(`Maximum ${this.plugin.settings.maxImmediateTasks} tasks in immediate.`);
            return;
          }
          void this.moveTask(task, section, "immediate", data);
        });
      });
    }
    if (section === "immediate" && !task.completed) {
      menu.addItem((item) => {
        item.setTitle("Move to this week").setIcon("arrow-down").onClick(() => {
          void this.moveTask(task, section, "thisWeek", data);
        });
      });
    }
    menu.addSeparator();
    if (!task.completed) {
      menu.addItem((item) => {
        item.setTitle("Deprioritize").setIcon("arrow-down-to-line").onClick(() => {
          void this.moveTask(task, section, "unscheduled", data).then(() => {
            new import_obsidian.Notice("Task moved to backlog.");
          });
        });
      });
    }
    if (task.sourceFile) {
      menu.addItem((item) => {
        item.setTitle("Open source file").setIcon("file").onClick(() => {
          const file = this.plugin.app.vault.getAbstractFileByPath(task.sourceFile);
          if (file instanceof import_obsidian.TFile) {
            void this.plugin.app.workspace.getLeaf().openFile(file);
          }
        });
      });
    }
    menu.addItem((item) => {
      item.setTitle("Delete").setIcon("trash").onClick(() => {
        const fromIndex = data.tasks[section].findIndex((t) => t.id === task.id);
        if (fromIndex > -1) {
          data.tasks[section].splice(fromIndex, 1);
          void this.plugin.saveTaskData(data).then(() => {
            void this.render();
            new import_obsidian.Notice("Task deleted");
          });
        }
      });
    });
    menu.showAtMouseEvent(e);
  }
};

// src/AddTaskModal.ts
var import_obsidian2 = require("obsidian");
var AddTaskModal = class extends import_obsidian2.Modal {
  constructor(plugin, defaultToThisWeek, onSubmit) {
    super(plugin.app);
    this.taskTitle = "";
    this.taskUrl = "";
    this.taskDoDate = "";
    this.taskDoTime = "";
    this.plugin = plugin;
    this.defaultToThisWeek = defaultToThisWeek;
    this.addToThisWeek = defaultToThisWeek;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("focus-add-task-modal");
    contentEl.createEl("h2", { text: "Add task" });
    new import_obsidian2.Setting(contentEl).setName("Task").addText((text) => {
      text.setPlaceholder("What needs to be done?").onChange((value) => {
        this.taskTitle = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && this.taskTitle.trim()) {
          this.submit();
        }
      });
      setTimeout(() => text.inputEl.focus(), 10);
    });
    new import_obsidian2.Setting(contentEl).setName("URL").setDesc("Optional link for this task").addText((text) => {
      text.setPlaceholder("https://...").onChange((value) => {
        this.taskUrl = value;
      });
    });
    const doDateSetting = new import_obsidian2.Setting(contentEl).setName("Reminder date").setDesc("When to be reminded about this task");
    const quickButtonsContainer = doDateSetting.controlEl.createDiv("focus-quick-date-buttons");
    const todayBtn = quickButtonsContainer.createEl("button", { text: "Today", cls: "focus-quick-date-btn" });
    todayBtn.addEventListener("click", () => {
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      this.taskDoDate = today;
      dateInput.value = today;
    });
    const tomorrowBtn = quickButtonsContainer.createEl("button", { text: "Tomorrow", cls: "focus-quick-date-btn" });
    tomorrowBtn.addEventListener("click", () => {
      const tomorrow = /* @__PURE__ */ new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const dateStr = tomorrow.toISOString().split("T")[0];
      this.taskDoDate = dateStr;
      dateInput.value = dateStr;
    });
    const nextWeekBtn = quickButtonsContainer.createEl("button", { text: "Next week", cls: "focus-quick-date-btn" });
    nextWeekBtn.addEventListener("click", () => {
      const nextWeek = /* @__PURE__ */ new Date();
      nextWeek.setDate(nextWeek.getDate() + 7);
      const dateStr = nextWeek.toISOString().split("T")[0];
      this.taskDoDate = dateStr;
      dateInput.value = dateStr;
    });
    const dateInput = doDateSetting.controlEl.createEl("input", {
      type: "date",
      cls: "focus-date-input"
    });
    dateInput.addEventListener("change", (e) => {
      this.taskDoDate = e.target.value;
    });
    new import_obsidian2.Setting(contentEl).setName("Reminder time").setDesc("Optional time for the reminder").addText((text) => {
      text.inputEl.type = "time";
      text.inputEl.addClass("focus-time-input");
      text.onChange((value) => {
        this.taskDoTime = value;
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Add to this week").setDesc("Schedule this task for the current week").addToggle((toggle) => {
      toggle.setValue(this.addToThisWeek).onChange((value) => {
        this.addToThisWeek = value;
      });
    });
    new import_obsidian2.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Add task").setCta().onClick(() => {
        if (this.taskTitle.trim()) {
          this.submit();
        }
      });
    }).addButton((btn) => {
      btn.setButtonText("Cancel").onClick(() => {
        this.close();
      });
    });
  }
  submit() {
    const section = this.addToThisWeek ? "thisWeek" : "unscheduled";
    const url = this.taskUrl.trim() || void 0;
    const doDate = this.taskDoDate || void 0;
    const doTime = this.taskDoTime || void 0;
    this.onSubmit(this.taskTitle.trim(), section, url, doDate, doTime);
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/PlanningModal.ts
var import_obsidian3 = require("obsidian");
var PlanningModal = class extends import_obsidian3.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.data = null;
    this.plugin = plugin;
  }
  async onOpen() {
    this.data = await this.plugin.loadTaskData();
    this.render();
  }
  render() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("focus-planning-modal");
    if (!this.data)
      return;
    const today = /* @__PURE__ */ new Date();
    const dateStr = today.toLocaleDateString("en-US", {
      weekday: "long",
      month: "short",
      day: "numeric",
      year: "numeric"
    });
    contentEl.createEl("h2", { text: `Planning view \u2014 ${dateStr}` });
    this.renderThisWeekSection(contentEl);
    this.renderUnscheduledSection(contentEl);
    this.renderFooter(contentEl);
    const actionsEl = contentEl.createEl("div", { cls: "focus-planning-actions" });
    const weeklyNoteBtn = actionsEl.createEl("button", {
      text: "Open weekly note",
      cls: "focus-weekly-note-btn"
    });
    weeklyNoteBtn.addEventListener("click", () => {
      void this.plugin.openOrCreateWeeklyNote();
    });
    const closeBtn = actionsEl.createEl("button", {
      text: "Done planning",
      cls: "mod-cta"
    });
    closeBtn.addEventListener("click", () => this.close());
  }
  renderFooter(container) {
    const footer = container.createEl("div", { cls: "focus-footer" });
    const fileLink = footer.createEl("a", {
      text: "Edit task file",
      cls: "focus-file-link",
      href: "#"
    });
    fileLink.addEventListener("click", (e) => {
      e.preventDefault();
      const filePath = this.plugin.settings.taskFilePath;
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian3.TFile) {
        this.close();
        void this.plugin.app.workspace.getLeaf().openFile(file);
      }
    });
  }
  renderGoalsSection(container) {
    const section = container.createEl("div", { cls: "focus-planning-section" });
    section.createEl("h3", { text: "This week's goals" });
    const goalsList = section.createEl("div", { cls: "focus-goals-list" });
    if (this.data.goals.length === 0) {
      goalsList.createEl("p", {
        text: "No goals set for this week. Add goals to organize your tasks.",
        cls: "focus-empty-state"
      });
    } else {
      for (const goal of this.data.goals) {
        this.renderGoal(goalsList, goal);
      }
    }
    const addGoalEl = section.createEl("div", { cls: "focus-add-goal" });
    const input = addGoalEl.createEl("input", {
      type: "text",
      placeholder: "Add a goal for this week...",
      cls: "focus-goal-input"
    });
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && input.value.trim()) {
        const newGoal = {
          id: Date.now().toString(36) + Math.random().toString(36).substring(2, 11),
          title: input.value.trim()
        };
        this.data.goals.push(newGoal);
        void this.plugin.saveTaskData(this.data).then(() => {
          this.render();
        });
      }
    });
  }
  renderGoal(container, goal) {
    const goalEl = container.createEl("div", { cls: "focus-goal-item" });
    const linkedTasks = this.getTasksForGoal(goal.id);
    const completedCount = linkedTasks.filter((t) => t.completed).length;
    const totalCount = linkedTasks.length;
    const titleEl = goalEl.createEl("div", { cls: "focus-goal-info" });
    titleEl.createEl("span", {
      text: `\u{1F3AF} ${goal.title}`,
      cls: "focus-goal-title"
    });
    if (totalCount > 0) {
      titleEl.createEl("span", {
        text: `${completedCount}/${totalCount} tasks`,
        cls: "focus-goal-progress"
      });
    }
    const deleteBtn = goalEl.createEl("button", {
      text: "\xD7",
      cls: "focus-goal-delete"
    });
    deleteBtn.addEventListener("click", () => {
      this.unlinkTasksFromGoal(goal.id);
      const index = this.data.goals.findIndex((g) => g.id === goal.id);
      if (index > -1) {
        this.data.goals.splice(index, 1);
        void this.plugin.saveTaskData(this.data).then(() => {
          this.render();
        });
      }
    });
  }
  getTasksForGoal(goalId) {
    const allTasks = [
      ...this.data.tasks.immediate,
      ...this.data.tasks.thisWeek,
      ...this.data.tasks.unscheduled
    ];
    return allTasks.filter((t) => t.goalId === goalId);
  }
  getTasksWithoutGoal() {
    const scheduledTasks = [
      ...this.data.tasks.immediate,
      ...this.data.tasks.thisWeek
    ];
    return scheduledTasks.filter((t) => !t.goalId);
  }
  unlinkTasksFromGoal(goalId) {
    for (const section of ["immediate", "thisWeek", "unscheduled"]) {
      for (const task of this.data.tasks[section]) {
        if (task.goalId === goalId) {
          delete task.goalId;
        }
      }
    }
  }
  renderThisWeekSection(container) {
    const section = container.createEl("div", { cls: "focus-planning-section" });
    section.createEl("h3", { text: "This week's tasks" });
    const allScheduled = [
      ...this.data.tasks.immediate,
      ...this.data.tasks.thisWeek
    ];
    if (allScheduled.length === 0) {
      section.createEl("p", {
        text: "No tasks scheduled this week. Schedule tasks from unscheduled below.",
        cls: "focus-empty-state"
      });
      return;
    }
    const completed = allScheduled.filter((t) => t.completed).length;
    const total = allScheduled.length;
    section.createEl("p", {
      text: `${completed}/${total} tasks completed`,
      cls: "focus-progress-summary"
    });
    const taskList = section.createEl("div", { cls: "focus-planning-task-list" });
    const sorted = [...allScheduled].sort((a, b) => {
      if (a.completed === b.completed)
        return 0;
      return a.completed ? 1 : -1;
    });
    for (const task of sorted) {
      this.renderPlanningTaskSimple(taskList, task);
    }
  }
  // Keep the old method for potential future use
  renderTasksByGoalSection(container) {
    const section = container.createEl("div", { cls: "focus-planning-section" });
    section.createEl("h3", { text: "This week's tasks" });
    const allScheduled = [
      ...this.data.tasks.immediate,
      ...this.data.tasks.thisWeek
    ];
    if (allScheduled.length === 0) {
      section.createEl("p", {
        text: "No tasks scheduled this week. Schedule tasks from unscheduled below.",
        cls: "focus-empty-state"
      });
      return;
    }
    const completed = allScheduled.filter((t) => t.completed).length;
    const total = allScheduled.length;
    section.createEl("p", {
      text: `${completed}/${total} tasks completed`,
      cls: "focus-progress-summary"
    });
    const tasksByGoal = /* @__PURE__ */ new Map();
    for (const goal of this.data.goals) {
      tasksByGoal.set(goal.id, []);
    }
    tasksByGoal.set(null, []);
    for (const task of allScheduled) {
      const goalId = task.goalId || null;
      if (!tasksByGoal.has(goalId)) {
        tasksByGoal.set(null, [...tasksByGoal.get(null) || [], task]);
      } else {
        tasksByGoal.get(goalId).push(task);
      }
    }
    for (const goal of this.data.goals) {
      const tasks = tasksByGoal.get(goal.id) || [];
      if (tasks.length > 0) {
        this.renderGoalTaskGroup(section, goal, tasks);
      }
    }
    const unassignedTasks = tasksByGoal.get(null) || [];
    if (unassignedTasks.length > 0) {
      this.renderGoalTaskGroup(section, null, unassignedTasks);
    }
  }
  renderGoalTaskGroup(container, goal, tasks) {
    const groupEl = container.createEl("div", { cls: "focus-goal-group" });
    const headerText = goal ? `\u{1F3AF} ${goal.title}` : "\u{1F4CB} No goal assigned";
    groupEl.createEl("div", {
      text: headerText,
      cls: "focus-goal-group-header"
    });
    const taskList = groupEl.createEl("div", { cls: "focus-planning-task-list" });
    const sorted = [...tasks].sort((a, b) => {
      if (a.completed === b.completed)
        return 0;
      return a.completed ? 1 : -1;
    });
    for (const task of sorted) {
      this.renderPlanningTask(taskList, task);
    }
  }
  renderUnscheduledSection(container) {
    const section = container.createEl("div", { cls: "focus-planning-section" });
    const headerEl = section.createEl("div", { cls: "focus-section-header-row" });
    headerEl.createEl("h3", { text: `Unscheduled (${this.data.tasks.unscheduled.length} tasks)` });
    if (this.data.tasks.unscheduled.length === 0) {
      section.createEl("p", {
        text: "No unscheduled tasks. Add tasks during the week with quick-add.",
        cls: "focus-empty-state"
      });
      return;
    }
    const taskList = section.createEl("div", { cls: "focus-planning-task-list" });
    for (const task of this.data.tasks.unscheduled) {
      this.renderUnscheduledTask(taskList, task);
    }
  }
  renderPlanningTaskSimple(container, task) {
    const taskEl = container.createEl("div", {
      cls: `focus-planning-task ${task.completed ? "focus-task-completed" : ""}`
    });
    const checkbox = task.completed ? "\u2611" : "\u2610";
    taskEl.createEl("span", {
      text: `${checkbox} ${task.title}`,
      cls: "focus-task-text"
    });
    const actionsEl = taskEl.createEl("div", { cls: "focus-task-actions" });
    if (!task.completed) {
      const deprioritizeBtn = actionsEl.createEl("button", {
        text: "\u2193",
        cls: "focus-deprioritize-btn",
        attr: { title: "Move to unscheduled" }
      });
      deprioritizeBtn.addEventListener("click", () => {
        void this.moveTaskToSection(task, task.section, "unscheduled").then(() => {
          new import_obsidian3.Notice(`"${task.title}" moved to unscheduled`);
        });
      });
    }
    const sectionLabel = task.section === "immediate" ? "Immediate" : "This week";
    actionsEl.createEl("span", {
      text: sectionLabel,
      cls: "focus-task-section-badge"
    });
  }
  renderPlanningTask(container, task) {
    const taskEl = container.createEl("div", {
      cls: `focus-planning-task ${task.completed ? "focus-task-completed" : ""}`
    });
    const checkbox = task.completed ? "\u2611" : "\u2610";
    taskEl.createEl("span", {
      text: `${checkbox} ${task.title}`,
      cls: "focus-task-text"
    });
    const actionsEl = taskEl.createEl("div", { cls: "focus-task-actions" });
    const goalBtn = actionsEl.createEl("button", {
      cls: "focus-goal-assign-btn"
    });
    goalBtn.textContent = task.goalId ? this.getGoalEmoji(task.goalId) : "\u{1F3AF}";
    goalBtn.title = task.goalId ? `Assigned to: ${this.getGoalTitle(task.goalId)}` : "Assign to goal";
    goalBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.showGoalAssignMenu(e, task);
    });
    const sectionLabel = task.section === "immediate" ? "Immediate" : "This week";
    actionsEl.createEl("span", {
      text: sectionLabel,
      cls: "focus-task-section-badge"
    });
  }
  renderUnscheduledTask(container, task) {
    const taskEl = container.createEl("div", { cls: "focus-unscheduled-task" });
    taskEl.createEl("span", {
      text: `\u2610 ${task.title}`,
      cls: "focus-task-text"
    });
    const actionsEl = taskEl.createEl("div", { cls: "focus-task-actions" });
    const scheduleBtn = actionsEl.createEl("button", {
      text: "Schedule",
      cls: "focus-schedule-btn"
    });
    scheduleBtn.addEventListener("click", () => {
      void this.moveTaskToSection(task, "unscheduled", "thisWeek").then(() => {
        new import_obsidian3.Notice(`"${task.title}" scheduled for this week`);
      });
    });
    const deleteBtn = actionsEl.createEl("button", {
      text: "\xD7",
      cls: "focus-delete-btn"
    });
    deleteBtn.addEventListener("click", () => {
      const index = this.data.tasks.unscheduled.findIndex((t) => t.id === task.id);
      if (index > -1) {
        this.data.tasks.unscheduled.splice(index, 1);
        void this.plugin.saveTaskData(this.data).then(() => {
          this.render();
          new import_obsidian3.Notice("Task deleted");
        });
      }
    });
  }
  showGoalAssignMenu(e, task) {
    const menu = new import_obsidian3.Menu();
    if (task.goalId) {
      menu.addItem((item) => {
        item.setTitle("Remove from goal").setIcon("x").onClick(() => {
          delete task.goalId;
          void this.plugin.saveTaskData(this.data).then(() => {
            this.render();
            this.plugin.refreshFocusView();
          });
        });
      });
      menu.addSeparator();
    }
    for (const goal of this.data.goals) {
      menu.addItem((item) => {
        const isCurrentGoal = task.goalId === goal.id;
        item.setTitle(`\u{1F3AF} ${goal.title}`).setIcon(isCurrentGoal ? "check" : "").onClick(() => {
          task.goalId = goal.id;
          void this.plugin.saveTaskData(this.data).then(() => {
            this.render();
            this.plugin.refreshFocusView();
            new import_obsidian3.Notice(`Task assigned to "${goal.title}"`);
          });
        });
      });
    }
    if (this.data.goals.length === 0) {
      menu.addItem((item) => {
        item.setTitle("No goals yet - add one above").setDisabled(true);
      });
    }
    menu.showAtMouseEvent(e);
  }
  getGoalTitle(goalId) {
    const goal = this.data.goals.find((g) => g.id === goalId);
    return (goal == null ? void 0 : goal.title) || "Unknown";
  }
  getGoalEmoji(goalId) {
    return "\u2705";
  }
  async moveTaskToSection(task, fromSection, toSection) {
    const fromIndex = this.data.tasks[fromSection].findIndex((t) => t.id === task.id);
    if (fromIndex > -1) {
      this.data.tasks[fromSection].splice(fromIndex, 1);
    }
    task.section = toSection;
    this.data.tasks[toSection].push(task);
    await this.plugin.saveTaskData(this.data);
    this.render();
    this.plugin.refreshFocusView();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.plugin.refreshFocusView();
  }
};

// src/EndOfDayModal.ts
var import_obsidian4 = require("obsidian");
var EndOfDayModal = class extends import_obsidian4.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.data = null;
    this.plugin = plugin;
  }
  async onOpen() {
    this.data = await this.plugin.loadTaskData();
    this.render();
  }
  render() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("focus-end-of-day-modal");
    if (!this.data)
      return;
    contentEl.createEl("h2", { text: "End of day review" });
    const today = (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
      weekday: "long",
      month: "short",
      day: "numeric"
    });
    contentEl.createEl("p", { text: today, cls: "focus-date-subtitle" });
    const immediateTasks = this.data.tasks.immediate;
    const completedImmediate = immediateTasks.filter((t) => t.completed);
    const incompleteImmediate = immediateTasks.filter((t) => !t.completed);
    const progressSection = contentEl.createEl("div", { cls: "focus-review-section" });
    progressSection.createEl("h3", { text: "Today's focus" });
    if (immediateTasks.length === 0) {
      progressSection.createEl("p", {
        text: "No tasks were in your immediate focus today.",
        cls: "focus-empty-state"
      });
    } else {
      const progressText = `${completedImmediate.length}/${immediateTasks.length} tasks completed`;
      progressSection.createEl("p", { text: progressText, cls: "focus-progress-text" });
      if (completedImmediate.length > 0) {
        const completedList = progressSection.createEl("div", { cls: "focus-completed-list" });
        completedList.createEl("h4", { text: "Completed" });
        for (const task of completedImmediate) {
          completedList.createEl("div", {
            text: `\u2713 ${task.title}`,
            cls: "focus-completed-task"
          });
        }
      }
      if (incompleteImmediate.length > 0) {
        const incompleteList = progressSection.createEl("div", { cls: "focus-incomplete-list" });
        incompleteList.createEl("h4", { text: "Still pending" });
        for (const task of incompleteImmediate) {
          const taskRow = incompleteList.createEl("div", { cls: "focus-incomplete-task-row" });
          taskRow.createEl("span", { text: `\u25CB ${task.title}` });
          const completeBtn = taskRow.createEl("button", {
            text: "Complete",
            cls: "focus-quick-complete-btn"
          });
          completeBtn.addEventListener("click", () => {
            task.completed = true;
            void this.plugin.saveTaskData(this.data).then(() => {
              if (task.sourceFile) {
                void this.plugin.syncTaskCompletionToSource(task);
              }
              this.plugin.refreshFocusView();
              this.render();
            });
          });
        }
      }
    }
    const messageSection = contentEl.createEl("div", { cls: "focus-review-message" });
    if (immediateTasks.length === 0) {
      messageSection.createEl("p", { text: "Plan your focus for tomorrow!" });
    } else if (completedImmediate.length === immediateTasks.length) {
      messageSection.createEl("p", { text: "Great job! You completed everything." });
    } else if (completedImmediate.length >= immediateTasks.length / 2) {
      messageSection.createEl("p", { text: "You did amazing today! The rest can wait until tomorrow." });
    } else {
      messageSection.createEl("p", { text: "Every step counts. Tomorrow is a new day." });
    }
    const actionsEl = contentEl.createEl("div", { cls: "focus-review-actions" });
    const dailyNoteBtn = actionsEl.createEl("button", {
      text: "Open daily note",
      cls: "focus-daily-note-btn"
    });
    dailyNoteBtn.addEventListener("click", () => {
      void this.plugin.openOrCreateDailyNote();
    });
    const doneBtn = actionsEl.createEl("button", {
      text: "Done",
      cls: "mod-cta"
    });
    doneBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/SettingsTab.ts
var import_obsidian5 = require("obsidian");
var FocusSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.renderHotkeysSection(containerEl);
    new import_obsidian5.Setting(containerEl).setName("Tasks").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Task file path").setDesc("The path to the markdown file that stores your tasks (relative to vault root)").addText(
      (text) => text.setPlaceholder("focus-tasks.md").setValue(this.plugin.settings.taskFilePath).onChange(async (value) => {
        this.plugin.settings.taskFilePath = value || "focus-tasks.md";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Maximum immediate tasks").setDesc("Maximum number of tasks allowed in the immediate section (3-5 recommended)").addSlider(
      (slider) => slider.setLimits(1, 7, 1).setValue(this.plugin.settings.maxImmediateTasks).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxImmediateTasks = value;
        await this.plugin.saveSettings();
        this.plugin.refreshFocusView();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Vault task sync").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Sync tasks from vault").setDesc("Pull tasks from other notes in your vault into the unscheduled backlog").addDropdown(
      (dropdown) => dropdown.addOption("off", "Off - only use the Focus task file").addOption("all", "All - sync all tasks from vault").addOption("tag", "Tag - only sync tasks with a specific tag").setValue(this.plugin.settings.vaultSyncMode).onChange(async (value) => {
        this.plugin.settings.vaultSyncMode = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.vaultSyncMode === "tag") {
      new import_obsidian5.Setting(containerEl).setName("Sync tag").setDesc("Only tasks containing this tag will be synced (e.g., #focus)").addText(
        (text) => text.setPlaceholder("#focus").setValue(this.plugin.settings.vaultSyncTag).onChange(async (value) => {
          if (value && !value.startsWith("#")) {
            value = "#" + value;
          }
          this.plugin.settings.vaultSyncTag = value || "#focus";
          await this.plugin.saveSettings();
        })
      );
    }
    if (this.plugin.settings.vaultSyncMode !== "off") {
      new import_obsidian5.Setting(containerEl).setName("Sync now").setDesc("Manually scan vault for tasks and add to unscheduled").addButton(
        (button) => button.setButtonText("Sync tasks").setCta().onClick(() => {
          button.setButtonText("Syncing...");
          button.setDisabled(true);
          void this.plugin.syncVaultTasks().then(() => {
            button.setButtonText("Sync tasks");
            button.setDisabled(false);
          });
        })
      );
    }
    new import_obsidian5.Setting(containerEl).setName("Reminders").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Weekly planning reminder").setDesc("Show a reminder to do weekly planning").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.planningReminderEnabled).onChange(async (value) => {
        this.plugin.settings.planningReminderEnabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.planningReminderEnabled) {
      new import_obsidian5.Setting(containerEl).setName("Planning day").setDesc("Which day to show the planning reminder").addDropdown((dropdown) => {
        for (let i = 0; i <= 6; i++) {
          dropdown.addOption(i.toString(), DAY_NAMES[i]);
        }
        dropdown.setValue(this.plugin.settings.planningReminderDay.toString()).onChange(async (value) => {
          this.plugin.settings.planningReminderDay = parseInt(value);
          await this.plugin.saveSettings();
        });
      });
    }
    new import_obsidian5.Setting(containerEl).setName("End of day review").setDesc("Show a reminder to review your day").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.endOfDayReviewEnabled).onChange(async (value) => {
        this.plugin.settings.endOfDayReviewEnabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.endOfDayReviewEnabled) {
      new import_obsidian5.Setting(containerEl).setName("Review time").setDesc("When to show the end of day review prompt (24h format)").addText(
        (text) => text.setPlaceholder("21:00").setValue(this.plugin.settings.endOfDayReviewTime).onChange(async (value) => {
          if (/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(value)) {
            this.plugin.settings.endOfDayReviewTime = value;
            await this.plugin.saveSettings();
            this.plugin.scheduleEndOfDayReview();
          }
        })
      );
    }
    new import_obsidian5.Setting(containerEl).setName("Weekly rollover").setDesc("What happens to incomplete tasks when a new week starts").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Roll over immediate \u2192 this week").setDesc("Move incomplete immediate tasks to this week on planning day").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.rolloverImmediateToThisWeek).onChange(async (value) => {
        this.plugin.settings.rolloverImmediateToThisWeek = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Roll over this week \u2192 unscheduled").setDesc("Move incomplete this week tasks to unscheduled on planning day").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.rolloverThisWeekToUnscheduled).onChange(async (value) => {
        this.plugin.settings.rolloverThisWeekToUnscheduled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Periodic notes").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Daily notes folder").setDesc("Folder where daily notes are stored (leave empty for vault root)").addText(
      (text) => text.setPlaceholder("daily-notes/").setValue(this.plugin.settings.dailyNotesFolder).onChange(async (value) => {
        this.plugin.settings.dailyNotesFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Daily notes format").setDesc("Date format for daily note filenames (e.g., YYYY-MM-DD)").addText(
      (text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dailyNotesFormat).onChange(async (value) => {
        this.plugin.settings.dailyNotesFormat = value || "YYYY-MM-DD";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Weekly notes folder").setDesc("Folder where weekly notes are stored (leave empty for vault root)").addText(
      (text) => text.setPlaceholder("weekly-notes/").setValue(this.plugin.settings.weeklyNotesFolder).onChange(async (value) => {
        this.plugin.settings.weeklyNotesFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Weekly notes format").setDesc("Date format for weekly note filenames (e.g., YYYY-[W]WW)").addText(
      (text) => text.setPlaceholder("YYYY-[W]WW").setValue(this.plugin.settings.weeklyNotesFormat).onChange(async (value) => {
        this.plugin.settings.weeklyNotesFormat = value || "YYYY-[W]WW";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("About").setDesc("Focus is a visibility firewall for your tasks. It helps you focus on what matters now by hiding everything else.").setHeading();
  }
  renderHotkeysSection(containerEl) {
    new import_obsidian5.Setting(containerEl).setName("Keyboard shortcuts").setHeading();
    const commands = [
      { id: COMMAND_IDS.openFocusView, name: "Open view" },
      { id: COMMAND_IDS.openPlanningView, name: "Open planning" },
      { id: COMMAND_IDS.quickAddTask, name: "Quick add task" }
    ];
    for (const cmd of commands) {
      const hotkey = this.getHotkeyForCommand(cmd.id);
      const hotkeyText = hotkey ? this.formatHotkey(hotkey) : "Not set";
      new import_obsidian5.Setting(containerEl).setName(cmd.name).setDesc(hotkeyText).addButton(
        (button) => button.setButtonText("Set hotkey").onClick(() => {
          this.app.setting.openTabById("hotkeys");
          const hotkeyTab = this.app.setting.activeTab;
          if (hotkeyTab && hotkeyTab.searchComponent) {
            hotkeyTab.searchComponent.setValue("Focus:");
            hotkeyTab.updateHotkeyVisibility();
          }
        })
      );
    }
  }
  getHotkeyForCommand(commandId) {
    var _a;
    const customKeys = ((_a = this.app.hotkeyManager) == null ? void 0 : _a.customKeys) || {};
    const hotkeys = customKeys[commandId];
    if (hotkeys && hotkeys.length > 0) {
      return hotkeys[0];
    }
    return null;
  }
  formatHotkey(hotkey) {
    const parts = [];
    if (hotkey.modifiers.includes("Mod")) {
      parts.push("\u2318");
    }
    if (hotkey.modifiers.includes("Ctrl")) {
      parts.push("\u2303");
    }
    if (hotkey.modifiers.includes("Alt")) {
      parts.push("\u2325");
    }
    if (hotkey.modifiers.includes("Shift")) {
      parts.push("\u21E7");
    }
    parts.push(hotkey.key.toUpperCase());
    return parts.join(" ");
  }
};

// src/taskParser.ts
function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substring(2, 11);
}
function parseTaskLine(line, section) {
  const match = line.match(/^-\s*\[([ xX])\]\s*(.+)$/);
  if (!match)
    return null;
  const completed = match[1].toLowerCase() === "x";
  let title = match[2].trim();
  let url;
  let doDate;
  let doTime;
  const urlMatch = title.match(/\s*\s*(https?:\/\/\S+)\s*$/);
  if (urlMatch) {
    url = urlMatch[1];
    title = title.replace(urlMatch[0], "").trim();
  }
  const timeMatch = title.match(/\s*\s*(\d{1,2}:\d{2})\s*$/);
  if (timeMatch) {
    doTime = timeMatch[1];
    title = title.replace(timeMatch[0], "").trim();
  }
  const dateMatch = title.match(/\s*\s*(\d{4}-\d{2}-\d{2})\s*$/);
  if (dateMatch) {
    doDate = dateMatch[1];
    title = title.replace(dateMatch[0], "").trim();
  }
  return {
    id: generateId(),
    title,
    completed,
    section,
    url,
    doDate,
    doTime
  };
}
function parseFrontmatter(content) {
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  let weekOf = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  let goals = [];
  let bodyStart = 0;
  if (frontmatterMatch) {
    const frontmatter = frontmatterMatch[1];
    bodyStart = frontmatterMatch[0].length;
    const weekOfMatch = frontmatter.match(/weekOf:\s*(\d{4}-\d{2}-\d{2})/);
    if (weekOfMatch) {
      weekOf = weekOfMatch[1];
    }
    const goalsMatch = frontmatter.match(/goals:\n((?:\s+-\s+.+\n?)*)/);
    if (goalsMatch) {
      const goalLines = goalsMatch[1].split("\n").filter((line) => line.trim());
      goals = goalLines.map((line) => {
        const goalTitle = line.replace(/^\s*-\s*/, "").trim();
        return {
          id: generateId(),
          title: goalTitle
        };
      });
    }
  }
  return { weekOf, goals, bodyStart };
}
function parseTaskFile(content) {
  const { weekOf, goals, bodyStart } = parseFrontmatter(content);
  const body = content.slice(bodyStart);
  const tasks = {
    immediate: [],
    thisWeek: [],
    unscheduled: []
  };
  let currentSection = null;
  const lines = body.split("\n");
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (trimmedLine.toLowerCase() === "## immediate") {
      currentSection = "immediate";
      continue;
    } else if (trimmedLine.toLowerCase() === "## this week") {
      currentSection = "thisWeek";
      continue;
    } else if (trimmedLine.toLowerCase() === "## unscheduled") {
      currentSection = "unscheduled";
      continue;
    }
    if (currentSection && trimmedLine.startsWith("-")) {
      const task = parseTaskLine(trimmedLine, currentSection);
      if (task) {
        tasks[currentSection].push(task);
      }
    }
  }
  return {
    weekOf,
    goals,
    tasks
  };
}
function serializeTask(task) {
  const checkbox = task.completed ? "[x]" : "[ ]";
  const datePart = task.doDate ? ` \u{1F4C5} ${task.doDate}` : "";
  const timePart = task.doTime ? ` \u23F0 ${task.doTime}` : "";
  const urlPart = task.url ? ` \u{1F517} ${task.url}` : "";
  return `- ${checkbox} ${task.title}${datePart}${timePart}${urlPart}`;
}
function serializeTaskFile(data) {
  const lines = [];
  lines.push("---");
  lines.push(`weekOf: ${data.weekOf}`);
  if (data.goals.length > 0) {
    lines.push("goals:");
    for (const goal of data.goals) {
      lines.push(`  - ${goal.title}`);
    }
  } else {
    lines.push("goals: []");
  }
  lines.push("---");
  lines.push("");
  lines.push("## Immediate");
  for (const task of data.tasks.immediate) {
    lines.push(serializeTask(task));
  }
  lines.push("");
  lines.push("## This week");
  for (const task of data.tasks.thisWeek) {
    lines.push(serializeTask(task));
  }
  lines.push("");
  lines.push("## Unscheduled");
  for (const task of data.tasks.unscheduled) {
    lines.push(serializeTask(task));
  }
  lines.push("");
  return lines.join("\n");
}
function createDefaultTaskFile() {
  const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  return serializeTaskFile({
    weekOf: today,
    goals: [],
    tasks: {
      immediate: [],
      thisWeek: [],
      unscheduled: []
    }
  });
}

// src/main.ts
var FocusPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.hasShownPlanningPrompt = false;
    this.endOfDayTimeout = null;
    this.syncDebounceTimeout = null;
  }
  async onload() {
    await this.loadSettings();
    this.registerView(FOCUS_VIEW_TYPE, (leaf) => new FocusView(leaf, this));
    this.addRibbonIcon("target", "Open focus", () => {
      void this.activateFocusView();
    });
    this.addCommand({
      id: "open-view",
      name: "Open view",
      callback: () => {
        void this.activateFocusView();
      }
    });
    this.addCommand({
      id: "open-planning",
      name: "Open planning",
      callback: () => {
        this.openPlanningModal();
      }
    });
    this.addCommand({
      id: "quick-add-task",
      name: "Quick add task",
      callback: () => {
        this.openAddTaskModal(true);
      }
    });
    this.addCommand({
      id: "sync-vault-tasks",
      name: "Sync tasks from vault",
      callback: () => {
        void this.syncVaultTasks();
      }
    });
    this.addSettingTab(new FocusSettingTab(this.app, this));
    if (this.settings.planningReminderEnabled && this.isPlanningDay() && !this.hasShownPlanningPrompt) {
      this.hasShownPlanningPrompt = true;
      setTimeout(() => {
        new import_obsidian6.Notice(`It's ${this.getDayName(this.settings.planningReminderDay)}! Time for weekly planning.`, 5e3);
        this.openPlanningModal();
      }, 2e3);
    }
    if (this.settings.endOfDayReviewEnabled) {
      this.scheduleEndOfDayReview();
    }
    this.setupAutoSync();
    this.setupTaskFileWatcher();
    await this.ensureTaskFileExists();
  }
  onunload() {
    if (this.endOfDayTimeout) {
      clearTimeout(this.endOfDayTimeout);
    }
    if (this.syncDebounceTimeout) {
      clearTimeout(this.syncDebounceTimeout);
    }
  }
  /**
   * Setup auto-sync: watch for file changes and sync tasks automatically
   */
  setupAutoSync() {
    if (this.settings.vaultSyncMode === "off")
      return;
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (!(file instanceof import_obsidian6.TFile))
          return;
        if (!file.path.endsWith(".md"))
          return;
        if (file.path === (0, import_obsidian6.normalizePath)(this.settings.taskFilePath))
          return;
        this.debouncedSync();
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (!(file instanceof import_obsidian6.TFile))
          return;
        if (!file.path.endsWith(".md"))
          return;
        this.debouncedSync();
      })
    );
  }
  /**
   * Watch the focus task file for direct edits and refresh the sidebar
   */
  setupTaskFileWatcher() {
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (!(file instanceof import_obsidian6.TFile))
          return;
        if (file.path !== (0, import_obsidian6.normalizePath)(this.settings.taskFilePath))
          return;
        if (this.syncDebounceTimeout) {
          clearTimeout(this.syncDebounceTimeout);
        }
        this.syncDebounceTimeout = setTimeout(() => {
          this.refreshFocusView();
        }, 500);
      })
    );
  }
  /**
   * Debounced sync - waits 2 seconds after last change before syncing
   */
  debouncedSync() {
    if (this.settings.vaultSyncMode === "off")
      return;
    if (this.syncDebounceTimeout) {
      clearTimeout(this.syncDebounceTimeout);
    }
    this.syncDebounceTimeout = setTimeout(() => {
      void this.syncVaultTasks(true);
    }, 2e3);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isPlanningDay() {
    return (/* @__PURE__ */ new Date()).getDay() === this.settings.planningReminderDay;
  }
  getDayName(day) {
    const days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    return days[day];
  }
  scheduleEndOfDayReview() {
    if (this.endOfDayTimeout) {
      clearTimeout(this.endOfDayTimeout);
    }
    if (!this.settings.endOfDayReviewEnabled)
      return;
    const [hours, minutes] = this.settings.endOfDayReviewTime.split(":").map(Number);
    const now = /* @__PURE__ */ new Date();
    const reviewTime = /* @__PURE__ */ new Date();
    reviewTime.setHours(hours, minutes, 0, 0);
    if (reviewTime <= now) {
      reviewTime.setDate(reviewTime.getDate() + 1);
    }
    const msUntilReview = reviewTime.getTime() - now.getTime();
    console.log(`Focus: End of day review scheduled for ${reviewTime.toLocaleString()}`);
    this.endOfDayTimeout = setTimeout(() => {
      this.showEndOfDayReview();
      this.scheduleEndOfDayReview();
    }, msUntilReview);
  }
  showEndOfDayReview() {
    new import_obsidian6.Notice("Time for your end of day review!", 5e3);
    const modal = new EndOfDayModal(this);
    modal.open();
  }
  async activateFocusView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(FOCUS_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: FOCUS_VIEW_TYPE,
          active: true
        });
      }
    }
    if (leaf) {
      void workspace.revealLeaf(leaf);
    }
  }
  async ensureTaskFileExists() {
    const filePath = (0, import_obsidian6.normalizePath)(this.settings.taskFilePath);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file)
      return;
    try {
      const dir = filePath.substring(0, filePath.lastIndexOf("/"));
      if (dir && !this.app.vault.getAbstractFileByPath(dir)) {
        await this.app.vault.createFolder(dir);
      }
    } catch (e) {
    }
    try {
      const defaultContent = createDefaultTaskFile();
      await this.app.vault.create(filePath, defaultContent);
      new import_obsidian6.Notice(`Created task file: ${filePath}`);
    } catch (e) {
    }
  }
  async loadTaskData() {
    const filePath = (0, import_obsidian6.normalizePath)(this.settings.taskFilePath);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      const content = await this.app.vault.read(file);
      return parseTaskFile(content);
    }
    return {
      weekOf: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      goals: [],
      tasks: {
        immediate: [],
        thisWeek: [],
        unscheduled: []
      }
    };
  }
  async saveTaskData(data) {
    const filePath = (0, import_obsidian6.normalizePath)(this.settings.taskFilePath);
    let file = this.app.vault.getAbstractFileByPath(filePath);
    const content = serializeTaskFile(data);
    if (file instanceof import_obsidian6.TFile) {
      await this.app.vault.modify(file, content);
    } else {
      await this.ensureTaskFileExists();
      file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian6.TFile) {
        await this.app.vault.modify(file, content);
      }
    }
  }
  /**
   * Open the add task modal
   * @param defaultToThisWeek - If true, the "Add to This Week" checkbox will be checked by default
   */
  openAddTaskModal(defaultToThisWeek = false) {
    const modal = new AddTaskModal(this, defaultToThisWeek, (title, section, url, doDate, doTime) => {
      void this.addTask(title, section, url, doDate, doTime);
    });
    modal.open();
  }
  async addTask(title, section, url, doDate, doTime) {
    const data = await this.loadTaskData();
    if (section === "immediate") {
      const activeImmediate = data.tasks.immediate.filter((t) => !t.completed);
      if (activeImmediate.length >= this.settings.maxImmediateTasks) {
        new import_obsidian6.Notice(`Maximum ${this.settings.maxImmediateTasks} tasks in immediate. Move one out first.`);
        return;
      }
    }
    const newTask = {
      id: Date.now().toString(36) + Math.random().toString(36).substring(2, 11),
      title,
      completed: false,
      section,
      url,
      doDate,
      doTime
    };
    data.tasks[section].push(newTask);
    await this.saveTaskData(data);
    this.refreshFocusView();
    const sectionName = section === "immediate" ? "immediate" : section === "thisWeek" ? "this week" : "unscheduled";
    new import_obsidian6.Notice(`Task added to ${sectionName}`);
  }
  openPlanningModal() {
    const modal = new PlanningModal(this);
    modal.open();
  }
  refreshFocusView() {
    const leaves = this.app.workspace.getLeavesOfType(FOCUS_VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof FocusView) {
        void view.render();
      }
    }
  }
  /**
   * Scan the vault for tasks and sync them to the Unscheduled backlog
   * Also syncs completion status for existing synced tasks
   * @param silent - If true, don't show notices (used for auto-sync)
   */
  async syncVaultTasks(silent = false) {
    if (this.settings.vaultSyncMode === "off") {
      if (!silent) {
        new import_obsidian6.Notice("Vault sync is disabled. Enable it in settings.");
      }
      return 0;
    }
    const data = await this.loadTaskData();
    const taskFilePath = (0, import_obsidian6.normalizePath)(this.settings.taskFilePath);
    const existingTasksByTitle = /* @__PURE__ */ new Map();
    for (const section of ["immediate", "thisWeek", "unscheduled"]) {
      for (const task of data.tasks[section]) {
        existingTasksByTitle.set(task.title, { task, section });
      }
    }
    let newTasksCount = 0;
    let syncedCompletions = 0;
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path === taskFilePath)
        continue;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const match = line.match(/^[\s]*-\s*\[([xX\s])\]\s*(.+)$/);
        if (!match)
          continue;
        const isCompleted = match[1].toLowerCase() === "x";
        const taskText = match[2].trim();
        if (this.settings.vaultSyncMode === "tag") {
          if (!taskText.includes(this.settings.vaultSyncTag))
            continue;
        }
        const existing = existingTasksByTitle.get(taskText);
        if (existing) {
          if (existing.task.sourceFile === file.path && existing.task.completed !== isCompleted) {
            existing.task.completed = isCompleted;
            existing.task.sourceLine = i + 1;
            syncedCompletions++;
          }
        } else if (!isCompleted) {
          const newTask = {
            id: Date.now().toString(36) + Math.random().toString(36).substring(2, 11) + i,
            title: taskText,
            completed: false,
            section: "unscheduled",
            sourceFile: file.path,
            sourceLine: i + 1
          };
          data.tasks.unscheduled.push(newTask);
          existingTasksByTitle.set(taskText, { task: newTask, section: "unscheduled" });
          newTasksCount++;
        }
      }
    }
    if (newTasksCount > 0 || syncedCompletions > 0) {
      await this.saveTaskData(data);
      this.refreshFocusView();
    }
    if (!silent) {
      const messages = [];
      if (newTasksCount > 0) {
        messages.push(`${newTasksCount} new task${newTasksCount === 1 ? "" : "s"}`);
      }
      if (syncedCompletions > 0) {
        messages.push(`${syncedCompletions} completion${syncedCompletions === 1 ? "" : "s"} synced`);
      }
      if (messages.length > 0) {
        new import_obsidian6.Notice(`Vault sync: ${messages.join(", ")}`);
      } else {
        new import_obsidian6.Notice("Vault sync: already up to date");
      }
    }
    return newTasksCount + syncedCompletions;
  }
  /**
   * Sync task completion status back to the source file
   * Called when a task with sourceFile is completed/uncompleted
   * Uses content matching instead of line numbers for reliability
   */
  async syncTaskCompletionToSource(task) {
    if (!task.sourceFile)
      return;
    const file = this.app.vault.getAbstractFileByPath(task.sourceFile);
    if (!(file instanceof import_obsidian6.TFile))
      return;
    try {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const taskTitle = task.title.trim();
      let foundIndex = -1;
      for (let i = 0; i < lines.length; i++) {
        const line2 = lines[i];
        const match = line2.match(/^(\s*-\s*)\[([xX\s])\]\s*(.+)$/);
        if (match) {
          const lineTaskText = match[3].trim();
          if (lineTaskText === taskTitle) {
            foundIndex = i;
            break;
          }
        }
      }
      if (foundIndex === -1) {
        console.warn("Focus: Could not find task in source file:", task.title);
        return;
      }
      const line = lines[foundIndex];
      const originalLine = line;
      if (task.completed) {
        lines[foundIndex] = line.replace(/^(\s*-\s*)\[\s*\]/, "$1[x]");
      } else {
        lines[foundIndex] = line.replace(/^(\s*-\s*)\[[xX]\]/, "$1[ ]");
      }
      if (lines[foundIndex] !== originalLine) {
        await this.app.vault.modify(file, lines.join("\n"));
        task.sourceLine = foundIndex + 1;
      }
    } catch (error) {
      console.error("Focus: Failed to sync task completion to source file", error);
    }
  }
  /**
   * Open a wiki-linked note from a task
   */
  async openLinkedNote(link) {
    const match = link.match(/\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/);
    if (!match)
      return;
    const notePath = match[1];
    const file = this.app.metadataCache.getFirstLinkpathDest(notePath, "");
    if (file) {
      await this.app.workspace.getLeaf().openFile(file);
    } else {
      const newFile = await this.app.vault.create(`${notePath}.md`, "");
      await this.app.workspace.getLeaf().openFile(newFile);
    }
  }
  /**
   * Format a date according to a format string (e.g., YYYY-MM-DD, YYYY-[W]WW)
   * Brackets [...] are used to escape literal characters (like moment.js)
   */
  formatDate(date, format) {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    const tempDate = new Date(date.getTime());
    tempDate.setHours(0, 0, 0, 0);
    tempDate.setDate(tempDate.getDate() + 3 - (tempDate.getDay() + 6) % 7);
    const week1 = new Date(tempDate.getFullYear(), 0, 4);
    const weekNumber = (1 + Math.round(((tempDate.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7)).toString().padStart(2, "0");
    const literals = [];
    let result = format.replace(/\[([^\]]+)\]/g, (_, content) => {
      literals.push(content);
      return `\0${literals.length - 1}\0`;
    });
    result = result.replace("YYYY", year.toString()).replace("MM", month).replace("DD", day).replace("WW", weekNumber);
    result = result.replace(/\x00(\d+)\x00/g, (_, index) => literals[parseInt(index)]);
    return result;
  }
  /**
   * Open or create today's daily note
   */
  async openOrCreateDailyNote() {
    const today = /* @__PURE__ */ new Date();
    const filename = this.formatDate(today, this.settings.dailyNotesFormat);
    const folder = this.settings.dailyNotesFolder.replace(/\/$/, "");
    const filePath = folder ? `${folder}/${filename}.md` : `${filename}.md`;
    let file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file) {
      if (folder) {
        const folderExists = this.app.vault.getAbstractFileByPath(folder);
        if (!folderExists) {
          await this.app.vault.createFolder(folder);
        }
      }
      file = await this.app.vault.create(filePath, `# ${filename}

`);
      new import_obsidian6.Notice(`Created daily note: ${filename}`);
    }
    if (file instanceof import_obsidian6.TFile) {
      await this.app.workspace.getLeaf().openFile(file);
    }
  }
  /**
   * Open or create this week's weekly note
   */
  async openOrCreateWeeklyNote() {
    const today = /* @__PURE__ */ new Date();
    const filename = this.formatDate(today, this.settings.weeklyNotesFormat);
    const folder = this.settings.weeklyNotesFolder.replace(/\/$/, "");
    const filePath = folder ? `${folder}/${filename}.md` : `${filename}.md`;
    let file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file) {
      if (folder) {
        const folderExists = this.app.vault.getAbstractFileByPath(folder);
        if (!folderExists) {
          await this.app.vault.createFolder(folder);
        }
      }
      file = await this.app.vault.create(filePath, `# ${filename}

`);
      new import_obsidian6.Notice(`Created weekly note: ${filename}`);
    }
    if (file instanceof import_obsidian6.TFile) {
      await this.app.workspace.getLeaf().openFile(file);
    }
  }
  /**
   * Perform weekly rollover of tasks
   */
  async performWeeklyRollover() {
    const data = await this.loadTaskData();
    let changed = false;
    if (this.settings.rolloverImmediateToThisWeek) {
      const incompleteTasks = data.tasks.immediate.filter((t) => !t.completed);
      for (const task of incompleteTasks) {
        task.section = "thisWeek";
        data.tasks.thisWeek.push(task);
        changed = true;
      }
      data.tasks.immediate = data.tasks.immediate.filter((t) => t.completed);
    }
    if (this.settings.rolloverThisWeekToUnscheduled) {
      const incompleteTasks = data.tasks.thisWeek.filter((t) => !t.completed);
      for (const task of incompleteTasks) {
        task.section = "unscheduled";
        data.tasks.unscheduled.push(task);
        changed = true;
      }
      data.tasks.thisWeek = data.tasks.thisWeek.filter((t) => t.completed);
    }
    data.weekOf = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    if (changed) {
      await this.saveTaskData(data);
      this.refreshFocusView();
      new import_obsidian6.Notice("Weekly rollover complete");
    }
  }
};
